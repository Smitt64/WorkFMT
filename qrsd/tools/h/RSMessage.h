// -------------------------------------------------------------------------------------------------
// 2010-12-06  Интерфейс для работы с системными (инструментальными) сообщениями

#ifndef _RSSYSTMESSAGE_H_
#define _RSSYSTMESSAGE_H_

#include "platform.h"
#include "tooldef.h"


// -----------------------------------------------------------------------------
// Обертка для облегчения использования RSSendMessage
#define  dRSSendMessageEx(msg, data, add, flag)  RSSendMessage(CRSMessage((msg), (data), (add)), (flag))
#define  dRSSendMessage(msg, data, add)          RSSendMessage(CRSMessage((msg), (data), (add)), false)

// -----------------------------------------------------------------------------
// Поддерживаемые сообщения
enum TERSMessage
   {
    eMsg_None           = -2,      // Служебный тип сообщения (отсутствует)
    eMsg_All            = -1,      // Служебный тип сообщения (все)

    eMsg_Zero           = 0,       // Нулевое сообщение (служебный резерв)

    eMsg_Allocate,                 // Выделение памяти с помощью Allocate
    eMsg_FreeMem,                  // Освобожение памяти с помощью FreeMem

    eMsg_ReadyInput,               // Аналог символа "R", выводимого в EasyWin-режиме при готовности системы к вводу

    eMsg_WaitKeyboardBegin,        // Ожидание ввода с клавитуры или мыши
    eMsg_WaitKeyboardEnd,          // Завершение ожидания ввода с клавиатуры или мыши

    eMsg_RSMessageDone,            // Деинициализация механизма сообщений

    eMsg_PlayRep        = 500,     // Выполнение макрофайла
    eMsg_RunMacro,                 // Вызов макроса
    eMsg_PlayRepEnd,               // Завершение выполнения макрофайла
    eMsg_RunMacroEnd,              // Завершение выполнения макроса

    // -------------------------------------------
    eMsg_ToolsInterface = 5000,    // Далее идут интерфейсные сообщения инструмента

    eMsg_BeforeShowPanel,          // Выдается непосредственно перед отображением панели на экране
    eMsg_AfterShowPanel,           // Выдается сразу после отображения панели на экране
    eMsg_BeforeRemovePanel,        // Выдается непосредственно перед удалением панели с экрана
    eMsg_AfterRemovePanel,         // Выдается сразу после удаления панели с экрана

    eMsg_TestHorMenu,              // Выдаётся при вызове TestHM
    eMsg_SelectHorMenu,            // Выдаётся при выборе пользователя

    eMsg_cwinExBegin,              // Выдаётся при вызове cwinEx
    eMsg_cwinExEnd,                // Возвращает выбор пользователя

    eMsg_procfldBegin,             // Выдаётся при вызове procfld
    eMsg_procfldEnd,               // Возвращает выбор пользователя (но вызывается перед PanProc)

    eMsg_EditFileBegin,            // Выдаётся перед выводом редактора
    eMsg_EditFileEnd,              // Выдаётся перед закрытием редактора

    eMsg_procfldEndReal,           // Настоящая eMsg_procfldEnd

    eMsg_TestVertMenu,             // Выдаётся при вызове LoopM
    eMsg_SelectVertMenu,           // Выдаётся при выборе пользователя

    // -------------------------------------------
    eMsg_User           = 10000    // С этого идентификатора начинается диапазон пользовательских сообщений
   };

// -----------------------------------------------------------------------------
// Для мнемонического удобства
#define  eMsg_PlayRepBegin   eMsg_PlayRep
#define  eMsg_RunMacroBegin  eMsg_RunMacro

// -----------------------------------------------------------------------------
// Предопределенные статусы возврата
enum TERSMessageStatus
   {
    eMsgStatus_Blocked                = -5,  // Обработчик заблокирован с помощью RSControlMessageBlockMode()
    eMsgStatus_NoUserRecursionHandler = -4,  // Отсутствует пользовательский обработчик рекурсивных сообщений
    eMsgStatus_LimitRecursion         = -3,  // Превышен лимит вложенных сообщений
    eMsgStatus_Disable                = -2,  // Механизм сообщений неактивен
    eMsgStatus_NoHandler              = -1,  // Отсутствует обработчик для данного сообщения
    eMsgStatus_Ok                     =  0,  // Чаще всего "Успех"
    eMsgStatus_NeedChange             =  1   // Обработчик изменил исходное значение
   };

// -----------------------------------------------------------------------------
// Режимы блокировки сообщений
enum TERSMessageBlockMode
   {
    eMsgBlockMode_None                = 0,   // Блокировка отсутствует
                                             // Значения 1 и 2 зарезервированы
    eMsgBlockMode_Interface           = 4,   // Блокировка интерфейсных сообщений ([5000; 9999])
    eMsgBlockMode_User                = 8    // Блокировка пользовательских сообщений (с 10000 и выше)
   };

// -----------------------------------------------------------------------------
// Структура дополнительных данных для eMsg_PlayRep/eMsg_PlayRepEnd
typedef struct TSMsgPlayRep
      {
       int          type;     // Тип вызова (пока не используется)
       const char  *output,   // Файл отчёта
                   *nspace;   // Пространство имён
       int          stat;     // Для сообщения eMsg_PlayRepEnd содержит значение STD_USERDATA::stat
      } TSMsgPlayRep;

// -----------------------------------------------------------------------------
// Основная структура для параметра сообщений eMsg_WaitKeyboardBegin/eMsg_WaitKeyboardEnd
typedef struct TSMsgKeyboard
      {
       int   version;         // Версия структуры (пока 1)
       int   key,             // Код клавиши
             ungkey;          // Возвращённый код клавиши
       int   scan,            // Скэн-код клавиши
             flags;           // Флаги клавиш
      } TSMsgKeyboard;

// -----------------------------------------------------------------------------
// Основная структура для параметра сообщений eMsg_cwinExBegin/eMsg_cwinExEnd
typedef struct TSMsgCWinEx
      {
       int           version;         // Версия структуры (пока 1)
       const char  **texts,           // Массив строк сообщения
                   **buttons;         // Массив названий кнопок
       int           nTexts,          // Размер массива строк сообщения
                     nButtons;        // Размер массива названий кнопок
       int           currButton;      // Кнопка по-умолчанию
       const char   *head,            // Заголовок сообщения
                    *status;          // Статус-строка сообщения
       int           infoType;        // ?
       long          errCode;         // ?
      } TSMsgCWinEx;

// -----------------------------------------------------------------------------
// Основная структура для параметра сообщений eMsg_EditFileBegin/eMsg_EditFileEnd
typedef struct TSMsgEditFile
      {
       int           version;         // Версия структуры (пока 1)
       const char   *file,            // Имя (+путь) к открываемому файлу
                    *output,          // Выходной файл
                    *head;            // Заголовок
       int           mode;            // Режим редактора (см. константы с префиксом V_ из
                                      // rstools\tools\h\edit\viewed.h)
      } TSMsgEditFile;


// -----------------------------------------------------------------------------
// Класс данных сообщения
class _TOOLEXP CRSMessage
    {
     private :
       TERSMessage  m_pv_Message,        // Сообщение
                    m_pv_ParentMessage;  // Родительское сообщение (устанавливается для обработчика всех сообщений)
       void        *m_pv_Data,           // Данные сообщения
                   *m_pv_AddData;        // Дополнительные данные сообщения

       // ----------------------------------------
       void _Init(TERSMessage msg = eMsg_None, TERSMessage parent = eMsg_None, void *data = NULL, void *add = NULL);

     public :
       // ----------------------------------------
       CRSMessage(TERSMessage msg, void *data = NULL, void *add = NULL);
       CRSMessage(TERSMessage msg, TERSMessage parent, void *data = NULL, void *add = NULL);

       // ----------------------------------------
       // Получить идентификатор сообщения
       TERSMessage Message(void) const;

       // Получить идентификатор родительского сообщения
       TERSMessage ParentMessage(void) const;

       // ----------------------------------------
       // Получить данные сообщения
       void *Data(void) const;

       // ----------------------------------------
       // Получить дополнительные данные сообщения
       void *AddData(void) const;
    };

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// Включение\выключение механизма сообщений
// [in]  flagEnable - новое значение флага
// [ret]            - возвращает предыдущее состояние флага
_TOOLFUNC bool RSControlMessage(bool flagEnable);

// -----------------------------------------------------------------------------
// Управление режимом блокировки сообщений
// [in]  mode - новое значение режима (см. TERSMessageBlockMode)
// [ret]      - возвращает предыдущее состояние режима
int RSControlMessageBlockMode(int mode);

// -----------------------------------------------------------------------------
// Инициализация механизма сообщений
int RSMessageInit(void);

// -----------------------------------------------------------------------------
// Деинициализация механизма сообщений
void RSMessageDone(void);

// -----------------------------------------------------------------------------
// Отправка сообщений
// [in]    msg     - сообщение
// [in]    noBlock - принудительная отправка сообщения (несмотря на блокировку)
// [ret] - Возвращаемы значения:
//          0 -
//         -1 - обработчик для данного сообщения не был найден
//         -2 - механизм сообщений неактивен
//         -3 - превышен лимит вложенных сообщений
//         -5 - сообщение заблокировано
_TOOLFUNC int RSSendMessage(const CRSMessage &msg, bool noBlock = false);


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// Тип - указатель на функцию-обработчик сообщений
// [in]      msg - сообщение
// [ret] - Возвращаемы значения:
//         0 - сообщение было успешно обработано, остальные обработчики не вызывать
//        -1 - вызвать следующий обработчик в цепочке
typedef int (*TFRSMessageHandler)(const CRSMessage &msg);

// -----------------------------------------------------------------------------
// Добавление обработчика в список
// [in]  hMsg - хендл обработчика
// [in]  msg  - идентификатор сообщения (если в качестве msg будет передан тип
//              eMsg_All, обработчик будет получать все сообщения)
// [ret] - Возвращаемы значения:
//         true  - обработчик успешно добавлен
//         false - ошибка добавления обработчика
_TOOLFUNC bool RSAddMessageHandler(TFRSMessageHandler hMsg, TERSMessage msg);

// -----------------------------------------------------------------------------
// Удаление обработчика из списка
// [in]  hMsg - хендл обработчика (если в качестве hMsg будет передан NULL,
//              будут удалены все обработчики)
// [in]  msg  - идентификатор сообщения (если в качестве msg передана символическая
//              константа eMsg_None, то обработчик будет исключен из всех сообщений)
// [ret] - Возвращаемы значения:
//         true  - обработчик успешно удален
//         false - ошибка удаления обработчика
_TOOLFUNC bool RSRemoveMessageHandler(TFRSMessageHandler hMsg, TERSMessage msg);

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// Указатель на обработчик рекурсивных сообщений
// Значение, возвращаемое обработчиком рекурсивных сообщений, пока не используется.
typedef  TFRSMessageHandler  TFRecursionMessageHandler;

// -----------------------------------------------------------------------------
// Установить обработчик рекурсивных сообщений
// [in]  newMsg - указатель на новый обработчик сообщений
// [ret]        - возвращает указатель на предыдущий обработчик
_TOOLFUNC TFRecursionMessageHandler RSSetRecursionMessageHandler(TFRecursionMessageHandler newMsg);

// -----------------------------------------------------------------------------
// Установить максимальное количество вложенных сообщений одного вида
// [in]  newVal - новое максимальное значение
// [ret]        - вернуть предыдущее максимальное значение
_TOOLFUNC int RSSetMaxRecursionCount(int newVal);

// -----------------------------------------------------------------------------

#endif // _RSSYSTMESSAGE_H_

/* <-- EOF --> */